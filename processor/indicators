#!/usr/bin/env node

const SMA = require('technicalindicators').SMA;
const BB = require('technicalindicators').BollingerBands
const MACD = require('technicalindicators').MACD;
const math = require("mathjs");
const provider = require('../provider/coingecko');

const cache = require("cache");
const c = new cache(15 * 60 * 1000);

module.exports = class {

    constructor(exchangeConfig={ indicators: undefined }) {
        this.exchangeConfig = exchangeConfig;
        this.meta = {
            name: 'Indicators Processor by Event+',
            id: 'ipbe-101',
            version: 1
        };
    }

    SMA (values=[], period=this.exchangeConfig.indicators.SMA.period) {
        return SMA.calculate({period: period, values: values});
    }

    BB (values=[], period=this.exchangeConfig.indicators.BB.period) {
        return BB.calculate({period: period, values: values, stdDev: math.sqrt(math.sqrt(math.std(values)))});
    }

    MACD (values=[], fastPeriod=this.exchangeConfig.indicators.MACD.fastPeriod, slowPeriod=this.exchangeConfig.indicators.MACD.slowPeriod, signalPeriod=this.exchangeConfig.indicators.MACD.signalPeriod, SimpleMAOscillator=this.exchangeConfig.indicators.MACD.SimpleMAOscillator, SimpleMASignal=this.exchangeConfig.indicators.MACD.SimpleMASignal )  {
        return MACD.calculate({
            values: values,
            fastPeriod: fastPeriod,
            slowPeriod: slowPeriod,
            signalPeriod: signalPeriod ,
            SimpleMAOscillator: SimpleMAOscillator,
            SimpleMASignal: SimpleMASignal
        });
    }

    RVI (close=[], open=[], high=[], low=[]) {

        var chartData = [];
        for (const index in close) {
            chartData.push( (close[index]-open[index])/(high[index]-low[index]) );
        }

        return chartData;

    }

    MVRVZScope (values=[], ts=0, cs=0) {

        return new Promise((resolve, reject) => {

            var chartData = [];
            var marketCap = [];

            provider.market().then(function (event) {

                for (const key in values) {
                    marketCap.push(values[key] * event.total_supply)
                }

                for (const key in values) {

                    let mc = values[key] * event.total_supply;
                    let rc = values[key] * event.circulating_supply;

                    chartData.push( math.sqrt(math.sqrt((mc - rc)/(math.std(marketCap)))) );

                }

                resolve (chartData);

            });

        });


    }

}