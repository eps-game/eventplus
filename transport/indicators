#!/usr/bin/env node

var async = require("async");

module.exports = class {

    constructor(drivers={}, processors={}) {

        this.meta = {
            id: 'itbe-101',
            name: "Indicators Transport by Event+",
            version: 1
        };
        this.actions = [];
        this.transports = [];
        this.processors = [];
        this.mask = {
            'bdbe-101': {

            },
            'ddbe-101': {

            },
            'bmxdbe-101': {

            }
        }

        // Load drivers
        for (const driver in drivers) {
            let object = drivers[driver];
            if ('meta' in object) {
                if ('exchange' in object.meta) {
                    this.transports.push({
                        driver: object,
                        meta: object.meta
                    });
                }
            } else {
                throw `'${driver}' is not a driver`;
            }
        }

        // Load processors
        for (const processor in processors) {
            let object = processors[processor];
            if ('meta' in object) {
                this.processors.push({
                    processor: object,
                    meta: object.meta
                });
            } else {
                throw `'${processor}' is not a processor`;
            }
        }

    }

    on (action='default', callback=null) {
        return this.actions.push({
            action: action,
            function: callback
        });
    }

    call (action='default', data) {
        for (const callback of this.actions) {
            if ( (action === callback.action) || ('*' === callback.action)) {
                try {
                    callback.function(data, action)
                } catch (e) {
                    console.error(e)
                }
            }
        }
    }

    calculate (e, this_, _, processor) {

        async.waterfall([

            // Calculate default arrays
            function (callback) {

                var object = {
                    volume: [],
                    close: [],
                    high: [],
                    low: [],
                    open: [],
                    time: []
                };

                for (const _ of e) {
                    object.volume.push(_.volume);
                    object.close.push(_.close);
                    object.high.push(_.high);
                    object.low.push(_.low);
                    object.open.push(_.open);
                    object.time.push(_.time);
                }

                callback (null, object);
            },

            // SMA
            function(chart, callback) {

                var chartData = [];
                const indicator = processor.SMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, chartData);

            },

            // RVI
            function (chart, SMA, callback) {

                var chartData = [];
                const indicator = processor.RVI(chart.close, chart.open, chart.high, chart.low);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, chartData);

            },

            // Bollinger Bands
            function (chart, SMA, RVI, callback) {

                var chartData = {
                    'lower': [],
                    'middle': [],
                    'upper': []
                };

                const indicator = processor.BB(chart.close);

                for (const key in indicator) {

                    chartData.lower.push({
                        value: indicator[key].lower,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.middle.push({
                        value: indicator[key].middle,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.upper.push({
                        value: indicator[key].upper,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                callback(null, chart, SMA, RVI, chartData);

            },

            // MACD
            function (chart, SMA, RVI, BB, callback) {

                var chartData = {
                    'macd': [],
                    'signal': [],
                    'histogram': []
                };

                const indicator = processor.MACD(chart.close);

                for (const key in indicator) {

                    chartData.macd.push({
                        value: indicator[key].MACD,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.signal.push({
                        value: indicator[key].signal,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.histogram.push({
                        value: indicator[key].histogram,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                callback(null, chart, SMA, RVI, BB, chartData);

            },

            // MVRVZSCOPE
            function (chart, SMA, RVI, BB, MACD, callback) {

                processor.MVRVZScope(chart.close).then(function (indicator) {

                    var chartData = [];

                    for (const key in indicator) {
                        chartData.push({
                            value: indicator[key],
                            time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                        })
                    }

                    callback(null, chart, SMA, RVI, BB, MACD, chartData);

                });


            },

            // VOLUME
            function (chart, SMA, RVI, BB, MACD, MVRVZSCOPE, callback) {

                var chartData = [];

                for (const key in chart.volume) {
                    chartData.push({
                        value: chart.volume[key],
                        time: chart.time[key],
                        color: chart.volume[key] > 0 ? 'rgba(66, 91, 41, 0.4)' : 'rgba(97, 38, 38, 0.4)'
                    });
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZSCOPE, chartData);

            },

            // WMA
            function (chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, callback) {

                var chartData = [];

                const indicator = processor.WMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, chartData);

            },

            // EMA
            function (chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, callback) {

                var chartData = [];

                const indicator = processor.EMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, chartData);

            },

            // OBV
            function (chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, EMA, callback) {

                var chartData = [];
                const indicator = processor.OBV(chart.close, chart.volume);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, EMA, chartData);

            },

            // STOCHASTIC
            function (chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, EMA, OBV, callback) {

                var chartData = {
                    d: [],
                    k: []
                };

                const indicator = processor.STOCHASTIC(chart.close, chart.high, chart.low);

                for (const key in indicator) {

                    chartData.d.push({
                        value: indicator[key].d,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.k.push({
                        value: indicator[key].k,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, EMA, OBV, chartData);

            }

        ], function (err, chart, SMA, RVI, BB, MACD, MVRVZSCOPE, VOLUME, WMA, EMA, OBV, STOCHASTIC) {

            this_.call('SMA', {
                exchange: _.meta.exchange,
                chart: SMA
            });

            this_.call('WMA', {
                exchange: _.meta.exchange,
                chart: WMA
            });

            this_.call('EMA', {
                exchange: _.meta.exchange,
                chart: EMA
            });

            this_.call('RVI', {
                exchange: _.meta.exchange,
                chart: RVI
            });

            this_.call('BB', {
                exchange: _.meta.exchange,
                chart: BB
            });

            this_.call('MACD', {
                exchange: _.meta.exchange,
                chart: MACD
            });

            this_.call('MVRVZSCOPE', {
                exchange: _.meta.exchange,
                chart: MVRVZSCOPE
            });

            this_.call('VOLUME', {
                exchange: _.meta.exchange,
                chart: VOLUME
            });
            
            this_.call('OBV', {
                exchange: _.meta.exchange,
                chart: OBV
            });

            this_.call('STOCHASTIC', {
                exchange: _.meta.exchange,
                chart: STOCHASTIC
            });

        });

    }

    init () {

        const this_ = this;
        var processor = false;

        // Select processor
        for (const _ of this.processors) {
            if (_.meta.id == 'ipbe-101') {
                processor = _.processor;
            }
        }

        // If processor selected
        if (processor) {

            for (const _ of this.transports) {

                _.driver.on('getChartForTradingview', function (e) {
                    this_.calculate(e, this_, _, processor);
                });

            }

            this.call('init', true);

        } else {
            throw "Processor is not selected";
        }

    }

}