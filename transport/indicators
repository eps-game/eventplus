#!/usr/bin/env node

var async = require("async");
var prototype = require('../models/essence');

module.exports = class extends prototype {

    constructor() {

        super();

        this.meta = {
            id: 'itbe-101',
            name: "Indicators Transport by Event+",
            version: 1
        };
        this.mask = {
            'bdbe-101': {},
            'ddbe-101': {},
            'bmxdbe-101': {}
        }

    }

    calculate (e, driver, processor) {

        async.waterfall([

            // Calculate default arrays
            function (callback) {

                var object = {
                    volume: [],
                    close: [],
                    high: [],
                    low: [],
                    open: [],
                    time: []
                };

                for (const _ of e) {
                    object.volume.push(_.volume);
                    object.close.push(_.close);
                    object.high.push(_.high);
                    object.low.push(_.low);
                    object.open.push(_.open);
                    object.time.push(_.time);
                }

                callback (null, object);
            },

            // SMA
            function(chart, callback) {

                var chartData = [];
                const indicator = processor.SMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, chartData);

            },

            // RVI
            function (chart, SMA, callback) {

                var chartData = [];
                const indicator = processor.RVI(chart.close, chart.open, chart.high, chart.low);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, chartData);

            },

            // Bollinger Bands
            function (chart, SMA, RVI, callback) {

                var chartData = {
                    'lower': [],
                    'middle': [],
                    'upper': []
                };

                const indicator = processor.BB(chart.close);

                for (const key in indicator) {

                    chartData.lower.push({
                        value: indicator[key].lower,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.middle.push({
                        value: indicator[key].middle,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.upper.push({
                        value: indicator[key].upper,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                callback(null, chart, SMA, RVI, chartData);

            },

            // MACD
            function (chart, SMA, RVI, BB, callback) {

                var chartData = {
                    'macd': [],
                    'signal': [],
                    'histogram': []
                };

                const indicator = processor.MACD(chart.close);

                for (const key in indicator) {

                    chartData.macd.push({
                        value: indicator[key].MACD,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.signal.push({
                        value: indicator[key].signal,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.histogram.push({
                        value: indicator[key].histogram,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                callback(null, chart, SMA, RVI, BB, chartData);

            },

            // MVRVZScr
            function (chart, SMA, RVI, BB, MACD, callback) {

                processor.MVRVZScr(chart.close).then(function (indicator) {

                    var chartData = [];

                    for (const key in indicator) {
                        chartData.push({
                            value: indicator[key],
                            time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                        })
                    }

                    callback(null, chart, SMA, RVI, BB, MACD, chartData);

                });


            },

            // VOLUME
            function (chart, SMA, RVI, BB, MACD, MVRVZScr, callback) {

                var chartData = [];

                for (const key in chart.volume) {
                    chartData.push({
                        value: chart.volume[key],
                        time: chart.time[key],
                        color: chart.volume[key] > 0 ? 'rgba(66, 91, 41, 0.4)' : 'rgba(97, 38, 38, 0.4)'
                    });
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScr, chartData);

            },

            // WMA
            function (chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, callback) {

                var chartData = [];

                const indicator = processor.WMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, chartData);

            },

            // EMA
            function (chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, callback) {

                var chartData = [];

                const indicator = processor.EMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, chartData);

            },

            // OBV
            function (chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, EMA, callback) {

                var chartData = [];
                const indicator = processor.OBV(chart.close, chart.volume);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, EMA, chartData);

            },

            // STOCHASTIC
            function (chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, EMA, OBV, callback) {

                var chartData = {
                    d: [],
                    k: []
                };

                const indicator = processor.STOCHASTIC(chart.close, chart.high, chart.low);

                for (const key in indicator) {

                    chartData.d.push({
                        value: indicator[key].d,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.k.push({
                        value: indicator[key].k,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, EMA, OBV, chartData);

            }

        ], (err, chart, SMA, RVI, BB, MACD, MVRVZScr, VOLUME, WMA, EMA, OBV, STOCHASTIC) => {

            this.call('SMA', {
                exchange: driver.meta.exchange,
                chart: SMA
            });

            this.call('WMA', {
                exchange: driver.meta.exchange,
                chart: WMA
            });

            this.call('EMA', {
                exchange: driver.meta.exchange,
                chart: EMA
            });

            this.call('RVI', {
                exchange: driver.meta.exchange,
                chart: RVI
            });

            this.call('BB', {
                exchange: driver.meta.exchange,
                chart: BB
            });

            this.call('MACD', {
                exchange: driver.meta.exchange,
                chart: MACD
            });

            this.call('MVRVZScr', {
                exchange: driver.meta.exchange,
                chart: MVRVZScr
            });

            this.call('VOLUME', {
                exchange: driver.meta.exchange,
                chart: VOLUME
            });

            this.call('OBV', {
                exchange: driver.meta.exchange,
                chart: OBV
            });

            this.call('STOCHASTIC', {
                exchange: driver.meta.exchange,
                chart: STOCHASTIC
            });

        });


    }

    init () {

        let processor = this.go('processor', 'indicators');
        let driver = this.go('driver');

        if (processor) {

            if (driver) {

                for (const [name, object] of Object.entries(driver)) {
                    if ('on' in object) {
                        object.on('getChartForTradingview', (event) => {
                            this.calculate(event, object, processor);
                        });
                    }
                }

            } else {
                throw "Drivers is not setup";
            }

        } else {
            throw "Processor is not selected";
        }


    }

}
