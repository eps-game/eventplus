#!/usr/bin/env node
'use strict';

const async = require("async");
const prototype = require('../models/essence');

module.exports = class extends prototype {

    constructor() {

        super();

        this.meta = {
            id: 'itbe-101',
            name: "Indicators Transport by Event+",
            version: 1
        };
        this.mask = {
            'bdbe-101': {},
            'ddbe-101': {},
            'bmxdbe-101': {}
        }

    }

    calculate (e, driver, processor) {

        async.waterfall([

            // Calculate default arrays
            function (callback) {

                var object = {
                    volume: [],
                    close: [],
                    high: [],
                    low: [],
                    open: [],
                    time: []
                };

                for (const _ of e) {
                    object.volume.push(_.volume);
                    object.close.push(_.close);
                    object.high.push(_.high);
                    object.low.push(_.low);
                    object.open.push(_.open);
                    object.time.push(_.time);
                }

                callback (null, object);

            },

            // SMA
            function(chart, callback) {

                var chartData = [];
                const indicator = processor.SMA(chart.close);

                for (const key in indicator) {
                    if (typeof chart.time[key] == "number") {
                        chartData.push([
                            chart.time[ parseInt(key) + ( chart.time.length - indicator.length ) ],
                            indicator[key],
                        ])
                    }
                }

                callback(null, chart, chartData);

            },

            // RVI
            function (chart, SMA, callback) {

                var chartData = [];
                const indicator = processor.RVI(chart.close, chart.open, chart.high, chart.low);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, chartData.sweepChart());

            },

            // Bollinger Bands
            function (chart, SMA, RVI, callback) {

                var chartData = {
                    'lower': [],
                    'middle': [],
                    'upper': []
                };

                const indicator = processor.BB(chart.close);

                for (const key in indicator) {

                    chartData.lower.push({
                        value: indicator[key].lower,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.middle.push({
                        value: indicator[key].middle,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.upper.push({
                        value: indicator[key].upper,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                chartData.lower = chartData.lower.sweepChart()
                chartData.middle = chartData.middle.sweepChart()
                chartData.upper = chartData.upper.sweepChart()

                callback(null, chart, SMA, RVI, chartData);

            },

            // MACD
            function (chart, SMA, RVI, BB, callback) {

                var chartData = {
                    'macd': [],
                    'signal': [],
                    'histogram': []
                };

                const indicator = processor.MACD(chart.close);

                for (const key in indicator.outMACD) {

                    chartData.macd.push({
                        value: indicator.outMACD[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.outMACD.length)]
                    });

                    chartData.signal.push({
                        value: indicator.outMACDSignal[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.outMACD.length)]
                    });

                    chartData.histogram.push({
                        value: indicator.outMACDHist[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.outMACD.length)]
                    });

                }

                chartData.histogram = chartData.histogram.sweepChart()
                chartData.macd = chartData.macd.sweepChart()
                chartData.signal = chartData.signal.sweepChart()

                callback(null, chart, SMA, RVI, BB, chartData);

            },

            // MVRVZScope
            function (chart, SMA, RVI, BB, MACD, callback) {

                processor.MVRVZScope(chart.close).then(function (indicator) {

                    var chartData = [];

                    for (const key in indicator) {
                        chartData.push({
                            value: indicator[key],
                            time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                        })
                    }

                    callback(null, chart, SMA, RVI, BB, MACD, chartData.sweepChart());

                });


            },

            // VOLUME
            function (chart, SMA, RVI, BB, MACD, MVRVZScope, callback) {

                var chartData = [];

                for (const key in chart.volume) {
                    chartData.push({
                        value: chart.volume[key],
                        time: chart.time[key],
                        color: chart.volume[key] > 0 ? 'rgba(66, 91, 41, 0.4)' : 'rgba(97, 38, 38, 0.4)'
                    });
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScope, chartData);

            },

            // WMA
            function (chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, callback) {

                var chartData = [];

                const indicator = processor.WMA(chart.close);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, chartData.sweepChart());

            },

            // EMA
            function (chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, callback) {

                var chartData = [];

                const indicator = processor.EMA(chart.close);

                for (const key in indicator) {
                    if (typeof chart.time[key] == "number") {
                        chartData.push([
                            chart.time[ parseInt(key) + ( chart.time.length - indicator.length ) ],
                            indicator[key],
                        ])
                    }
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, chartData);

            },

            // OBV
            function (chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, callback) {

                var chartData = [];
                const indicator = processor.OBV(chart.close, chart.volume);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    })
                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, chartData.sweepChart());

            },

            // STOCHASTIC
            function (chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, OBV, callback) {

                var chartData = {
                    d: [],
                    k: []
                };

                const indicator = processor.STOCHASTIC(chart.close, chart.high, chart.low);

                for (const key in indicator) {

                    chartData.d.push({
                        value: indicator[key].d,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                    chartData.k.push({
                        value: indicator[key].k,
                        time: chart.time[parseInt(key) + (chart.time.length - indicator.length)]
                    });

                }

                chartData.d = chartData.d.sweepChart()
                chartData.k = chartData.k.sweepChart()

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, OBV, chartData);

            },

            // TradingVUE
            function (chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, OBV, STOCHASTIC, callback) {

                var chartData = [];

                for (const key in chart.time) {

                    if (typeof chart.time[key] == "number") {
                        chartData.push([
                            chart.time[key],
                            chart.open[key],
                            chart.high[key],
                            chart.low[key],
                            chart.close[key],
                            chart.volume[key]
                        ]);
                    }

                }

                callback(null, chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, OBV, STOCHASTIC, chartData);

            }

        ], (err, chart, SMA, RVI, BB, MACD, MVRVZScope, VOLUME, WMA, EMA, OBV, STOCHASTIC, TRADINGVUE) => {

            this.call('TRADINGVUE', {
                exchange: driver.meta.exchange,
                chart: TRADINGVUE
            });

            this.call('SMA', {
                exchange: driver.meta.exchange,
                chart: SMA
            });

            this.call('WMA', {
                exchange: driver.meta.exchange,
                chart: WMA
            });

            this.call('EMA', {
                exchange: driver.meta.exchange,
                chart: EMA
            });

            this.call('RVI', {
                exchange: driver.meta.exchange,
                chart: RVI
            });

            this.call('BB', {
                exchange: driver.meta.exchange,
                chart: BB
            });

            this.call('MACD', {
                exchange: driver.meta.exchange,
                chart: MACD
            });

            this.call('MVRVZSCOPE', {
                exchange: driver.meta.exchange,
                chart: MVRVZScope
            });

            this.call('VOLUME', {
                exchange: driver.meta.exchange,
                chart: VOLUME
            });

            this.call('OBV', {
                exchange: driver.meta.exchange,
                chart: OBV
            });

            this.call('STOCHASTIC', {
                exchange: driver.meta.exchange,
                chart: STOCHASTIC
            });

        });


    }

    init () {

        let processor = this.go('processor', 'indicators');
        let driver = this.go('driver');
        let logger = this.go('logger', 'logger');

        if (processor) {

            if (driver) {

                for (const [name, object] of Object.entries(driver)) {
                    if ('on' in object) {

                        object.on('getChartForTradingview', (event) => {
                            this.calculate(event, object, processor);
                        });

                        logger.log({
                            sender: `TRANSPORT / INDICATORS`,
                            message: 'Successfully subscribe on get chart event on driver for ' + name,
                            level: 'info'
                        });

                    } else {

                        logger.log({
                            sender: `TRANSPORT / INDICATORS`,
                            message: `The ${name} driver is outdated or damaged because it doesn't have the \`on\` method.`,
                            level: 'error'
                        });

                    }
                }

            } else {
                throw "Drivers is not setup";
            }

        } else {
            throw "Processor is not selected";
        }


    }

}
