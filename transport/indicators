#!/usr/bin/env node

var async = require("async");

module.exports = class {

    constructor(drivers={}, processors={}) {

        this.meta = {
            id: 'itbe-101',
            name: "Indicators Transport by Event+",
            version: 1
        };
        this.actions = [];
        this.transports = [];
        this.processors = [];
        this.mask = {
            'bdbe-101': {

            },
            'ddbe-101': {

            },
            'bmxdbe-101': {

            }
        }

        // Load drivers
        for (const driver in drivers) {
            let object = drivers[driver];
            if ('meta' in object) {
                if ('exchange' in object.meta) {
                    this.transports.push({
                        driver: object,
                        meta: object.meta
                    });
                }
            } else {
                throw `'${driver}' is not a driver`;
            }
        }

        // Load processors
        for (const processor in processors) {
            let object = processors[processor];
            if ('meta' in object) {
                this.processors.push({
                    processor: object,
                    meta: object.meta
                });
            } else {
                throw `'${processor}' is not a processor`;
            }
        }

    }

    on (action='default', callback=null) {
        return this.actions.push({
            action: action,
            function: callback
        });
    }

    call (action='default', data) {
        for (const callback of this.actions) {
            if ( (action === callback.action) || ('*' === callback.action)) {
                try {
                    callback.function(data, action)
                } catch (e) {
                    console.error(e)
                }
            }
        }
    }

    calculate (e, this_, _, processor) {

        async.waterfall([

            // SMA
            function(callback) {

                var chartData = [];
                var closes = [];

                for (const close of e) {
                    closes.push(parseFloat(close.close))
                }

                var indicator = processor.SMA(closes);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: e[key].time
                    })
                }

                callback(null, chartData);

            },

            // RVI
            function (SMA, callback) {

                var chartData = [];
                var close = [];
                var open = [];
                var high = [];
                var low = [];

                for (const _ of e) {
                    close.push(parseFloat(_.close))
                    open.push(parseFloat(_.open))
                    high.push(parseFloat(_.high))
                    low.push(parseFloat(_.low))
                }

                var indicator = processor.RVI(close, open, high, low);

                for (const key in indicator) {
                    chartData.push({
                        value: indicator[key],
                        time: e[key].time
                    })
                }

                callback(null, SMA, chartData);

            },

            // Bollinger Bands
            function (SMA, RVI, callback) {

                var chartData = {
                    'lower': [],
                    'middle': [],
                    'upper': []
                };
                var closes = [];

                for (const close of e) {
                    closes.push(parseFloat(close.close))
                }

                var indicator = processor.BB(closes);

                for (const key in indicator) {

                    chartData.lower.push({
                        value: indicator[key].lower,
                        time: e[key].time
                    });

                    chartData.middle.push({
                        value: indicator[key].middle,
                        time: e[key].time
                    });

                    chartData.upper.push({
                        value: indicator[key].upper,
                        time: e[key].time
                    });

                }

                callback(null, SMA, RVI, chartData);

            },

            // MACD
            function (SMA, RVI, BB, callback) {

                var chartData = {
                    'macd': [],
                    'signal': [],
                    'histogram': []
                };
                var closes = [];

                for (const close of e) {
                    closes.push(parseFloat(close.close))
                }

                var indicator = processor.MACD(closes);

                for (const key in indicator) {

                    chartData.macd.push({
                        value: indicator[key].MACD,
                        time: e[key].time
                    });

                    chartData.signal.push({
                        value: indicator[key].signal,
                        time: e[key].time
                    });

                    chartData.histogram.push({
                        value: indicator[key].histogram,
                        time: e[key].time
                    });

                }

                callback(null, SMA, RVI, BB, chartData);

            },

            // MVRVZSCOPE
            function (SMA, RVI, BB, MACD, callback) {

                var closes = [];

                for (const close of e) {
                    closes.push(parseFloat(close.close))
                }

                processor.MVRVZScope(closes).then(function (indicator) {

                    var chartData = [];

                    for (const key in indicator) {
                        chartData.push({
                            value: indicator[key],
                            time: e[key].time
                        })
                    }

                    callback(null, SMA, RVI, BB, MACD, chartData);

                });


            },

            // Values
            function (SMA, RVI, BB, MACD, MVRVZSCOPE, callback) {

                var chartData = [];
                var values = [];

                for (const close of e) {
                    values.push(parseFloat(close.volume))
                }

                for (const key in values) {
                    chartData.push({
                        value: values[key],
                        time: e[key].time
                    });
                }

                callback(null, SMA, RVI, BB, MACD, MVRVZSCOPE, chartData);

            }

        ], function (err, SMA, RVI, BB, MACD, MVRVZSCOPE, VALUES) {

            this_.call('SMA', {
                exchange: _.meta.exchange,
                chart: SMA
            });

            this_.call('RVI', {
                exchange: _.meta.exchange,
                chart: RVI
            });

            this_.call('BB', {
                exchange: _.meta.exchange,
                chart: BB
            });

            this_.call('MACD', {
                exchange: _.meta.exchange,
                chart: MACD
            });

            this_.call('MVRVZSCOPE', {
                exchange: _.meta.exchange,
                chart: MVRVZSCOPE
            });

            this_.call('VALUES', {
                exchange: _.meta.exchange,
                chart: VALUES
            });

        });

    }

    init () {

        const this_ = this;
        var processor = false;

        // Select processor
        for (const _ of this.processors) {
            if (_.meta.id == 'ipbe-101') {
                processor = _.processor;
            }
        }

        // If processor selected
        if (processor) {

            for (const _ of this.transports) {

                _.driver.on('getChartForTradingview', function (e) {
                    this_.calculate(e, this_, _, processor);
                });

            }

            this.call('init', true);

        } else {
            throw "Processor is not selected";
        }

    }

}